# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.cpp"
# 21 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.cpp"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/DatabaseConfigView.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/DatabaseConfigView.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h" 1
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h"
# 1 "/usr/include/c++/9/cstdint" 1 3
# 32 "/usr/include/c++/9/cstdint" 3
       
# 33 "/usr/include/c++/9/cstdint" 3





# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 1 3
# 256 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3

# 256 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 278 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 528 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/os_defines.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/9/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/x86_64-linux-gnu/c++/9/bits/os_defines.h" 2 3
# 529 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/cpu_defines.h" 1 3
# 532 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 2 3
# 39 "/usr/include/c++/9/cstdint" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 42 "/usr/include/c++/9/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/DNPTime.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/DNPTime.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48Type.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48Type.h"

# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48Type.h"
namespace openpal
{

class UInt48Type
{

public:

 explicit UInt48Type(int64_t value) : value(value)
 {}

 UInt48Type() : value(0)
 {}

 operator int64_t() const
 {
  return value;
 }

 int64_t value;
};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/DNPTime.h" 2

namespace opendnp3
{

typedef openpal::UInt48Type DNPTime;

}
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/Flags.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/Flags.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryQuality.h"
namespace opendnp3 {




enum class BinaryQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  CHATTER_FILTER = 0x20,

  RESERVED = 0x40,

  STATE = 0x80
};


}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBitBinaryQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBitBinaryQuality.h"
namespace opendnp3 {




enum class DoubleBitBinaryQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  CHATTER_FILTER = 0x20,

  STATE1 = 0x40,

  STATE2 = 0x80
};


}
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/CounterQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/CounterQuality.h"
namespace opendnp3 {




enum class CounterQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  ROLLOVER = 0x20,

  DISCONTINUITY = 0x40,

  RESERVED = 0x80
};


}
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/FrozenCounterQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/FrozenCounterQuality.h"
namespace opendnp3 {




enum class FrozenCounterQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  ROLLOVER = 0x20,

  DISCONTINUITY = 0x40,

  RESERVED = 0x80
};


}
# 28 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogQuality.h"
namespace opendnp3 {




enum class AnalogQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  OVERRANGE = 0x20,

  REFERENCE_ERR = 0x40,

  RESERVED = 0x80
};


}
# 29 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogOutputStatusQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogOutputStatusQuality.h"
namespace opendnp3 {




enum class AnalogOutputStatusQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  OVERRANGE = 0x20,

  REFERENCE_ERR = 0x40,

  RESERVED = 0x80
};


}
# 31 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryOutputStatusQuality.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryOutputStatusQuality.h"
namespace opendnp3 {




enum class BinaryOutputStatusQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  RESERVED1 = 0x20,

  RESERVED2 = 0x40,

  STATE = 0x80
};


}
# 32 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2

namespace opendnp3
{

template <class T>
inline uint8_t ToUnderlying(T flag)
{
 return static_cast<uint8_t>(flag);
}

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/Flags.h" 2

namespace opendnp3
{




class Flags
{
public:

 Flags() : value(0)
 {}

 Flags(uint8_t value) : value(value)
 {}

 inline bool IsSet(BinaryQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(AnalogQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(CounterQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(FrozenCounterQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(BinaryOutputStatusQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(AnalogOutputStatusQuality flag) const
 {
  return IsSetAny(flag);
 }

 inline void Set(BinaryQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(AnalogQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(CounterQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(FrozenCounterQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(BinaryOutputStatusQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(AnalogOutputStatusQuality flag)
 {
  SetAny(flag);
 }

 uint8_t value;

protected:

 template <class T>
 bool IsSetAny(T flag) const
 {
  return (value & static_cast<uint8_t>(flag)) != 0;
 }

 template <class T>
 void SetAny(T flag)
 {
  value |= static_cast<uint8_t>(flag);
 }
};

}
# 28 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 2

namespace opendnp3
{




class Measurement
{
public:

 Flags flags;
 DNPTime time;

protected:

 Measurement()
 {}

 Measurement(Flags flags) : flags(flags)
 {}

 Measurement(Flags flags, DNPTime time) : flags(flags), time(time)
 {}

};



template <class T>
class TypedMeasurement : public Measurement
{
public:

 T value;

 typedef T Type;

protected:

 TypedMeasurement(): Measurement(), value(0) {}
 TypedMeasurement(Flags flags) : Measurement(flags), value(0) {}
 TypedMeasurement(T value, Flags flags) : Measurement(flags), value(value) {}
 TypedMeasurement(T value, Flags flags, DNPTime time) : Measurement(flags, time), value(value) {}
};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBit.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBit.h"
namespace opendnp3 {




enum class DoubleBit : uint8_t
{

  INTERMEDIATE = 0x0,

  DETERMINED_OFF = 0x1,

  DETERMINED_ON = 0x2,

  INDETERMINATE = 0x3
};

uint8_t DoubleBitToType(DoubleBit arg);
DoubleBit DoubleBitFromType(uint8_t arg);
char const* DoubleBitToString(DoubleBit arg);

}
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/IntervalUnits.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/IntervalUnits.h"
namespace opendnp3 {




enum class IntervalUnits : uint8_t
{

  NoRepeat = 0x0,

  Milliseconds = 0x1,

  Seconds = 0x2,

  Minutes = 0x3,

  Hours = 0x4,

  Days = 0x5,

  Weeks = 0x6,

  Months7 = 0x7,

  Months8 = 0x8,

  Months9 = 0x9,

  Seasons = 0xA,

  Undefined = 0x7F
};

uint8_t IntervalUnitsToType(IntervalUnits arg);
IntervalUnits IntervalUnitsFromType(uint8_t arg);
char const* IntervalUnitsToString(IntervalUnits arg);

}
# 28 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 2

namespace opendnp3
{






class Binary : public TypedMeasurement<bool>
{
public:

 Binary();

 Binary(bool value);

 Binary(Flags flags);

 Binary(Flags flags, DNPTime time);

 Binary(bool value, Flags flags);

 Binary(bool value, Flags flags, DNPTime time);
};





class DoubleBitBinary : public TypedMeasurement<DoubleBit>
{
public:


 DoubleBitBinary();

 DoubleBitBinary(DoubleBit value);

 DoubleBitBinary(Flags flags);

 DoubleBitBinary(Flags flags, DNPTime time);

 DoubleBitBinary(DoubleBit value, Flags flags);

 DoubleBitBinary(DoubleBit value, Flags flags, DNPTime time);

private:

 static const uint8_t ValueMask = 0xC0;
 static const uint8_t QualityMask = 0x3F;

 static DoubleBit GetValue(Flags flags);

 static Flags GetFlags(Flags flags, DoubleBit state);
};







class BinaryOutputStatus : public TypedMeasurement<bool>
{
public:

 BinaryOutputStatus();

 BinaryOutputStatus(bool value);

 BinaryOutputStatus(Flags flags);

 BinaryOutputStatus(Flags flags, DNPTime time);

 BinaryOutputStatus(bool value, Flags flags);

 BinaryOutputStatus(bool value, Flags flags, DNPTime time);

};






class Analog : public TypedMeasurement<double>
{
public:

 Analog();

 Analog(double value);

 Analog(double value, Flags flags);

 Analog(double value, Flags flags, DNPTime time);
};





class Counter : public TypedMeasurement<uint32_t>
{
public:

 Counter();

 Counter(uint32_t value);

 Counter(uint32_t value, Flags flags);

 Counter(uint32_t value, Flags flags, DNPTime time);
};




class FrozenCounter : public TypedMeasurement<uint32_t>
{
public:

 FrozenCounter();

 FrozenCounter(uint32_t value);

 FrozenCounter(uint32_t value, Flags flags);

 FrozenCounter(uint32_t value, Flags flags, DNPTime time);
};





class AnalogOutputStatus : public TypedMeasurement<double>
{
public:

 AnalogOutputStatus();

 AnalogOutputStatus(double value);

 AnalogOutputStatus(double value, Flags flags);

 AnalogOutputStatus(double value, Flags flags, DNPTime time);
};





class TimeAndInterval
{
public:

 TimeAndInterval();

 TimeAndInterval(DNPTime time, uint32_t interval, uint8_t units);

 TimeAndInterval(DNPTime time, uint32_t interval, IntervalUnits units);

 IntervalUnits GetUnitsEnum() const;

 DNPTime time;
 uint32_t interval;
 uint8_t units;
};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/SecurityStat.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/SecurityStat.h"
namespace opendnp3
{






class SecurityStat
{
public:


 struct Value
 {
  uint16_t assocId;
  uint32_t count;
 };

 SecurityStat();

 SecurityStat(Value value, uint8_t quality, DNPTime time);

 SecurityStat(uint8_t quality, uint16_t assocId, uint32_t count);

 SecurityStat(uint8_t quality, uint16_t assocId, uint32_t count, DNPTime time);

 uint8_t quality;
 Value value;
 DNPTime time;
};

}
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventType.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventType.h"
namespace opendnp3
{

static const int NUM_OUTSTATION_EVENT_TYPES = 8;

enum class EventType : uint16_t
{
 Binary = 0,
 Analog = 1,
 Counter = 2,
 FrozenCounter = 3,
 DoubleBitBinary = 4,
 BinaryOutputStatus = 5,
 AnalogOutputStatus = 6,
 SecurityStat = 7
};

enum class EventClass : uint8_t
{
 EC1 = 0,
 EC2 = 1,
 EC3 = 2
};

}
# 28 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryVariation.h"
namespace opendnp3 {

enum class StaticBinaryVariation : uint8_t
{
  Group1Var1 = 0,
  Group1Var2 = 1
};


}
# 30 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticDoubleBinaryVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticDoubleBinaryVariation.h"
namespace opendnp3 {

enum class StaticDoubleBinaryVariation : uint8_t
{
  Group3Var2 = 0
};


}
# 31 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryOutputStatusVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryOutputStatusVariation.h"
namespace opendnp3 {

enum class StaticBinaryOutputStatusVariation : uint8_t
{
  Group10Var2 = 0
};


}
# 32 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticCounterVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticCounterVariation.h"
namespace opendnp3 {

enum class StaticCounterVariation : uint8_t
{
  Group20Var1 = 0,
  Group20Var2 = 1,
  Group20Var5 = 2,
  Group20Var6 = 3
};


}
# 33 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticFrozenCounterVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticFrozenCounterVariation.h"
namespace opendnp3 {

enum class StaticFrozenCounterVariation : uint8_t
{
  Group21Var1 = 0,
  Group21Var2 = 1,
  Group21Var5 = 2,
  Group21Var6 = 3,
  Group21Var9 = 4,
  Group21Var10 = 5
};


}
# 34 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogVariation.h"
namespace opendnp3 {

enum class StaticAnalogVariation : uint8_t
{
  Group30Var1 = 0,
  Group30Var2 = 1,
  Group30Var3 = 2,
  Group30Var4 = 3,
  Group30Var5 = 4,
  Group30Var6 = 5
};


}
# 35 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogOutputStatusVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogOutputStatusVariation.h"
namespace opendnp3 {

enum class StaticAnalogOutputStatusVariation : uint8_t
{
  Group40Var1 = 0,
  Group40Var2 = 1,
  Group40Var3 = 2,
  Group40Var4 = 3
};


}
# 36 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTimeAndIntervalVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTimeAndIntervalVariation.h"
namespace opendnp3 {

enum class StaticTimeAndIntervalVariation : uint8_t
{
  Group50Var4 = 0
};


}
# 37 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticSecurityStatVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticSecurityStatVariation.h"
namespace opendnp3 {

enum class StaticSecurityStatVariation : uint8_t
{
  Group121Var1 = 0
};


}
# 38 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryVariation.h"
namespace opendnp3 {

enum class EventBinaryVariation : uint8_t
{
  Group2Var1 = 0,
  Group2Var2 = 1,
  Group2Var3 = 2
};


}
# 40 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventDoubleBinaryVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventDoubleBinaryVariation.h"
namespace opendnp3 {

enum class EventDoubleBinaryVariation : uint8_t
{
  Group4Var1 = 0,
  Group4Var2 = 1,
  Group4Var3 = 2
};


}
# 41 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryOutputStatusVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryOutputStatusVariation.h"
namespace opendnp3 {

enum class EventBinaryOutputStatusVariation : uint8_t
{
  Group11Var1 = 0,
  Group11Var2 = 1
};


}
# 42 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventCounterVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventCounterVariation.h"
namespace opendnp3 {

enum class EventCounterVariation : uint8_t
{
  Group22Var1 = 0,
  Group22Var2 = 1,
  Group22Var5 = 2,
  Group22Var6 = 3
};


}
# 43 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventFrozenCounterVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventFrozenCounterVariation.h"
namespace opendnp3 {

enum class EventFrozenCounterVariation : uint8_t
{
  Group23Var1 = 0,
  Group23Var2 = 1,
  Group23Var5 = 2,
  Group23Var6 = 3
};


}
# 44 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogVariation.h"
namespace opendnp3 {

enum class EventAnalogVariation : uint8_t
{
  Group32Var1 = 0,
  Group32Var2 = 1,
  Group32Var3 = 2,
  Group32Var4 = 3,
  Group32Var5 = 4,
  Group32Var6 = 5,
  Group32Var7 = 6,
  Group32Var8 = 7
};


}
# 45 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogOutputStatusVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogOutputStatusVariation.h"
namespace opendnp3 {

enum class EventAnalogOutputStatusVariation : uint8_t
{
  Group42Var1 = 0,
  Group42Var2 = 1,
  Group42Var3 = 2,
  Group42Var4 = 3,
  Group42Var5 = 4,
  Group42Var6 = 5,
  Group42Var7 = 6,
  Group42Var8 = 7
};


}
# 46 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventSecurityStatVariation.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventSecurityStatVariation.h"
namespace opendnp3 {

enum class EventSecurityStatVariation : uint8_t
{
  Group122Var1 = 0,
  Group122Var2 = 1
};


}
# 47 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTypeBitmask.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTypeBitmask.h"
namespace opendnp3 {




enum class StaticTypeBitmask : uint16_t
{
  BinaryInput = 0x1,
  DoubleBinaryInput = 0x2,
  Counter = 0x4,
  FrozenCounter = 0x8,
  AnalogInput = 0x10,
  BinaryOutputStatus = 0x20,
  AnalogOutputStatus = 0x40,
  TimeAndInterval = 0x80
};


}
# 49 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Uncopyable.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Uncopyable.h"
namespace openpal
{



class Uncopyable
{
protected:
 Uncopyable() {}
 ~Uncopyable() {}

private:

 Uncopyable(const Uncopyable&) = delete;
 Uncopyable& operator=(const Uncopyable&) = delete;
};

class StaticOnly
{

private:

 StaticOnly() = delete;
 StaticOnly(const StaticOnly&) = delete;
 StaticOnly& operator=(const StaticOnly&) = delete;
};

}
# 51 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

namespace opendnp3
{


struct BinaryInfo : private openpal::StaticOnly
{
 typedef Binary meas_t;
 typedef bool value_t;
 typedef EventBinaryVariation event_variation_t;
 typedef StaticBinaryVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::Binary;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::BinaryInput;
 static const event_variation_t DefaultEventVariation = EventBinaryVariation::Group2Var1;
 static const static_variation_t DefaultStaticVariation = StaticBinaryVariation::Group1Var2;
};

struct DoubleBitBinaryInfo : private openpal::StaticOnly
{
 typedef DoubleBitBinary meas_t;
 typedef DoubleBit value_t;
 typedef EventDoubleBinaryVariation event_variation_t;
 typedef StaticDoubleBinaryVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::DoubleBitBinary;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::DoubleBinaryInput;
 static const event_variation_t DefaultEventVariation = EventDoubleBinaryVariation::Group4Var1;
 static const static_variation_t DefaultStaticVariation = StaticDoubleBinaryVariation::Group3Var2;
};

class BinaryOutputStatusInfo : private openpal::StaticOnly
{
public:

 typedef BinaryOutputStatus meas_t;
 typedef bool value_t;
 typedef EventBinaryOutputStatusVariation event_variation_t;
 typedef StaticBinaryOutputStatusVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::BinaryOutputStatus;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::BinaryOutputStatus;
 static const event_variation_t DefaultEventVariation = EventBinaryOutputStatusVariation::Group11Var1;
 static const static_variation_t DefaultStaticVariation = StaticBinaryOutputStatusVariation::Group10Var2;


};


struct AnalogInfo : private openpal::StaticOnly
{
 typedef Analog meas_t;
 typedef double value_t;
 typedef EventAnalogVariation event_variation_t;
 typedef StaticAnalogVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::Analog;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::AnalogInput;
 static const event_variation_t DefaultEventVariation = EventAnalogVariation::Group32Var1;
 static const static_variation_t DefaultStaticVariation = StaticAnalogVariation::Group30Var1;
};

struct CounterInfo : private openpal::StaticOnly
{
 typedef Counter meas_t;
 typedef uint32_t value_t;
 typedef EventCounterVariation event_variation_t;
 typedef StaticCounterVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::Counter;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::Counter;
 static const event_variation_t DefaultEventVariation = EventCounterVariation::Group22Var1;
 static const static_variation_t DefaultStaticVariation = StaticCounterVariation::Group20Var1;
};

struct FrozenCounterInfo : private openpal::StaticOnly
{
 typedef FrozenCounter meas_t;
 typedef uint32_t value_t;
 typedef EventFrozenCounterVariation event_variation_t;
 typedef StaticFrozenCounterVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::FrozenCounter;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::FrozenCounter;
 static const event_variation_t DefaultEventVariation = EventFrozenCounterVariation::Group23Var1;
 static const static_variation_t DefaultStaticVariation = StaticFrozenCounterVariation::Group21Var1;
};

struct AnalogOutputStatusInfo : private openpal::StaticOnly
{
 typedef AnalogOutputStatus meas_t;
 typedef double value_t;
 typedef EventAnalogOutputStatusVariation event_variation_t;
 typedef StaticAnalogOutputStatusVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::AnalogOutputStatus;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::AnalogOutputStatus;
 static const event_variation_t DefaultEventVariation = EventAnalogOutputStatusVariation::Group42Var1;
 static const static_variation_t DefaultStaticVariation = StaticAnalogOutputStatusVariation::Group40Var1;
};

struct TimeAndIntervalInfo : private openpal::StaticOnly
{
 typedef TimeAndInterval meas_t;
 typedef StaticTimeAndIntervalVariation static_variation_t;

 const static StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::TimeAndInterval;
 const static StaticTimeAndIntervalVariation DefaultStaticVariation = StaticTimeAndIntervalVariation::Group50Var4;
};

struct SecurityStatInfo : private openpal::StaticOnly
{
 typedef SecurityStat meas_t;
 typedef SecurityStat::Value value_t;
 typedef EventSecurityStatVariation event_variation_t;
 typedef StaticSecurityStatVariation static_variation_t;

 const static EventType EventTypeEnum = EventType::SecurityStat;
 const static event_variation_t DefaultEventVariation = EventSecurityStatVariation::Group122Var1;
 const static static_variation_t DefaultStaticVariation = StaticSecurityStatVariation::Group121Var1;
};

}
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/PointClass.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/PointClass.h"
namespace opendnp3 {




enum class PointClass : uint8_t
{

  Class0 = 0x1,

  Class1 = 0x2,

  Class2 = 0x4,

  Class3 = 0x8
};


}
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h" 2

namespace opendnp3
{


struct IndexConfig
{

 uint16_t vIndex = 0;
};


template <class Info>
struct StaticConfig : IndexConfig
{
 typename Info::static_variation_t svariation = Info::DefaultStaticVariation;
};

template <class Info>
struct EventConfig : StaticConfig<Info>
{
 PointClass clazz = PointClass::Class1;
 typename Info::event_variation_t evariation = Info::DefaultEventVariation;
};

template <class Info>
struct DeadbandConfig : EventConfig<Info>
{
 typename Info::value_t deadband = 0;
};

class BinaryConfig : public EventConfig<BinaryInfo> {};
class DoubleBitBinaryConfig : public EventConfig<DoubleBitBinaryInfo> {};
class AnalogConfig : public DeadbandConfig<AnalogInfo> {};
class CounterConfig : public DeadbandConfig<CounterInfo> {};
class FrozenCounterConfig : public DeadbandConfig<FrozenCounterInfo> {};
class BOStatusConfig : public EventConfig<BinaryOutputStatusInfo> {};
class AOStatusConfig : public DeadbandConfig<AnalogOutputStatusInfo> {};
class TimeAndIntervalConfig : public StaticConfig<TimeAndIntervalInfo> {};
class SecurityStatConfig : public IndexConfig {};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventCells.h" 1
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventCells.h"
namespace opendnp3
{


struct EmptyEventCell
{

};


template <class Spec>
struct EventCellBase
{
 PointClass clazz;
 typename Spec::meas_t lastEvent;
 typename Spec::event_variation_t evariation;

 void SetEventValue(const typename Spec::meas_t& value)
 {
  lastEvent = value;
 }

protected:

 EventCellBase() : clazz(PointClass::Class1), lastEvent(), evariation(Spec::DefaultEventVariation)
 {}
};


template <class Spec>
struct SimpleEventCell : EventCellBase<Spec>
{
 bool IsEvent(const typename Spec::config_t& config, const typename Spec::meas_t& newValue) const
 {
  return Spec::IsEvent(this->lastEvent, newValue);
 }
};


template <class Spec>
struct DeadbandEventCell : SimpleEventCell<Spec>
{
 bool IsEvent(const typename Spec::config_t& config, const typename Spec::meas_t& newValue) const
 {
  return Spec::IsEvent(this->lastEvent, newValue, config.deadband);
 }
};


}
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 2
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventTriggers.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventTriggers.h"
namespace opendnp3
{
namespace measurements
{
template <class T, class U>
bool IsEvent(const T& val1, const T& val2, T deadband)
{



 U diff = (val2 > val1) ? (static_cast<U>(val2) - static_cast<U>(val1)) : (static_cast<U>(val1) - static_cast<U>(val2));

 return diff > deadband;
}


bool IsEvent(const TypedMeasurement<double>& newMeas, const TypedMeasurement<double>& oldMeas, double deadband);

}
}
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 2

namespace opendnp3
{


struct BinarySpec : public BinaryInfo
{
 typedef BinaryConfig config_t;
 typedef SimpleEventCell<BinarySpec> event_cell_t;

 inline static bool IsQualityOnlineOnly(const Binary& binary)
 {
  return (binary.flags.value & 0b01111111) == static_cast<uint8_t>(BinaryQuality::ONLINE);
 }

 inline static bool IsEvent(const Binary& oldValue, const Binary& newValue)
 {
  return oldValue.flags.value != newValue.flags.value;
 }
};

struct DoubleBitBinarySpec : public DoubleBitBinaryInfo
{
 typedef DoubleBitBinaryConfig config_t;
 typedef SimpleEventCell<DoubleBitBinarySpec> event_cell_t;

 inline static bool IsEvent(const DoubleBitBinary& oldValue, const DoubleBitBinary& newValue)
 {
  return oldValue.flags.value != newValue.flags.value;
 }
};

struct BinaryOutputStatusSpec : public BinaryOutputStatusInfo
{
 typedef BOStatusConfig config_t;
 typedef SimpleEventCell<BinaryOutputStatusSpec> event_cell_t;

 inline static bool IsEvent(const BinaryOutputStatus& oldValue, const BinaryOutputStatus& newValue)
 {
  return oldValue.flags.value != newValue.flags.value;
 }
};


struct AnalogSpec : public AnalogInfo
{
 typedef AnalogConfig config_t;
 typedef DeadbandEventCell<AnalogSpec> event_cell_t;

 inline static bool IsEvent(const Analog& oldValue, const Analog& newValue, double deadband)
 {
  return measurements::IsEvent(newValue, oldValue, deadband);
 }
};

struct CounterSpec : public CounterInfo
{
 typedef CounterConfig config_t;
 typedef DeadbandEventCell<CounterSpec> event_cell_t;

 inline static bool IsEvent(const Counter& oldValue, const Counter& newValue, uint32_t deadband)
 {
  if (oldValue.flags.value != newValue.flags.value)
  {
   return true;
  }
  else
  {
   return measurements::IsEvent<uint32_t, uint64_t>(oldValue.value, newValue.value, deadband);
  }
 }
};

struct FrozenCounterSpec : public FrozenCounterInfo
{
 typedef FrozenCounterConfig config_t;
 typedef DeadbandEventCell<FrozenCounterSpec> event_cell_t;

 inline static bool IsEvent(const FrozenCounter& oldValue, const FrozenCounter& newValue, uint32_t deadband)
 {
  if (oldValue.flags.value != newValue.flags.value)
  {
   return true;
  }
  else
  {
   return measurements::IsEvent<uint32_t, uint64_t>(oldValue.value, newValue.value, deadband);
  }
 }
};

struct AnalogOutputStatusSpec : public AnalogOutputStatusInfo
{
 typedef AOStatusConfig config_t;
 typedef DeadbandEventCell<AnalogOutputStatusSpec> event_cell_t;

 inline static bool IsEvent(const AnalogOutputStatus& oldValue, const AnalogOutputStatus& newValue, double deadband)
 {
  return measurements::IsEvent(newValue, oldValue, deadband);
 }
};

struct TimeAndIntervalSpec : public TimeAndIntervalInfo
{
 typedef TimeAndIntervalConfig config_t;
 typedef EmptyEventCell event_cell_t;
};

struct SecurityStatSpec : public SecurityStatInfo
{
 typedef SecurityStatConfig config_t;
 typedef EmptyEventCell event_cell_t;

 inline static bool IsEvent(const SecurityStat& oldValue, const SecurityStat& newValue, uint32_t deadband)
 {
  if (oldValue.quality != newValue.quality)
  {
   return true;
  }
  else
  {
   return measurements::IsEvent<uint32_t, uint64_t>(oldValue.value.count, newValue.value.count, deadband);
  }
 }
};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/DatabaseConfigView.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/Cell.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/Cell.h"
namespace opendnp3
{




template <class Spec>
struct SelectedValue
{
 SelectedValue() : selected(false), value(), variation(Spec::DefaultStaticVariation)
 {}

 bool selected;
 typename Spec::meas_t value;
 typename Spec::static_variation_t variation;
};




template <class Spec>
struct Cell
{
 typename Spec::meas_t value;
 typename Spec::config_t config;
 typename Spec::event_cell_t event;
 SelectedValue<Spec> selection;

};





}
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/DatabaseConfigView.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/HasSize.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/HasSize.h"
namespace openpal
{

template <class SizeType>
class HasSize
{

public:

 HasSize(SizeType size_) : size(size_)
 {}

 SizeType Size() const
 {
  return size;
 }

 bool IsEmpty() const
 {
  return size == 0;
 }

 bool IsNotEmpty() const
 {
  return size != 0;
 }

protected:

 SizeType size;

};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 2

namespace openpal
{




template <class ValueType, class IndexType>
class ArrayView : public HasSize<IndexType>
{

public:

 static ArrayView<ValueType, IndexType> Empty()
 {
  return ArrayView(nullptr, 0);
 }

 ArrayView(ValueType* start, IndexType aSize) : HasSize<IndexType>(aSize), buffer(start)
 {}

 inline bool Contains(IndexType index) const
 {
  return index < this->size;
 }

 inline bool Contains(IndexType start, IndexType stop) const
 {
  return (start < stop) && Contains(stop);
 }

 inline ValueType& operator[](IndexType index)
 {
  
# 60 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 3 4
 (static_cast<void> (0))
# 60 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h"
                           ;
  return buffer[index];
 }

 inline const ValueType& operator[](IndexType index) const
 {
  
# 66 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 3 4
 (static_cast<void> (0))
# 66 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h"
                           ;
  return buffer[index];
 }

 template <class Action>
 void foreach(const Action& action)
 {
  for (IndexType i = 0; i < this->size; ++i)
  {
   action(buffer[i]);
  }
 }

 template <class Action>
 void foreachIndex(const Action& action)
 {
  for (IndexType i = 0; i < this->size; ++i)
  {
   action(buffer[i], i);
  }
 }

private:
 ValueType* buffer;
};



}
# 29 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/DatabaseConfigView.h" 2

namespace opendnp3
{
# 44 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/DatabaseConfigView.h"
class DatabaseConfigView
{

public:

 DatabaseConfigView(
     openpal::ArrayView<Cell<BinarySpec>, uint16_t> binaries,
     openpal::ArrayView<Cell<DoubleBitBinarySpec>, uint16_t> doubleBinaries,
     openpal::ArrayView<Cell<AnalogSpec>, uint16_t> analogs,
     openpal::ArrayView<Cell<CounterSpec>, uint16_t> counters,
     openpal::ArrayView<Cell<FrozenCounterSpec>, uint16_t> frozenCounters,
     openpal::ArrayView<Cell<BinaryOutputStatusSpec>, uint16_t> binaryOutputStatii,
     openpal::ArrayView<Cell<AnalogOutputStatusSpec>, uint16_t> analogOutputStatii,
     openpal::ArrayView<Cell<TimeAndIntervalSpec>, uint16_t> timeAndIntervals
 );



 openpal::ArrayView<Cell<BinarySpec>, uint16_t> binaries;
 openpal::ArrayView<Cell<DoubleBitBinarySpec>, uint16_t> doubleBinaries;
 openpal::ArrayView<Cell<AnalogSpec>, uint16_t> analogs;
 openpal::ArrayView<Cell<CounterSpec>, uint16_t> counters;
 openpal::ArrayView<Cell<FrozenCounterSpec>, uint16_t> frozenCounters;
 openpal::ArrayView<Cell<BinaryOutputStatusSpec>, uint16_t> binaryOutputStatii;
 openpal::ArrayView<Cell<AnalogOutputStatusSpec>, uint16_t> analogOutputStatii;
 openpal::ArrayView<Cell<TimeAndIntervalSpec>, uint16_t> timeAndIntervals;
};

}
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.h" 2


# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/DatabaseSizes.h" 1
# 26 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/DatabaseSizes.h"
namespace opendnp3
{




struct DatabaseSizes
{
 static DatabaseSizes BinaryOnly(uint16_t count)
 {
  return DatabaseSizes(count, 0, 0, 0, 0, 0, 0, 0);
 }

 static DatabaseSizes DoubleBinaryOnly(uint16_t count)
 {
  return DatabaseSizes(0, count, 0, 0, 0, 0, 0, 0);
 }

 static DatabaseSizes AnalogOnly(uint16_t count)
 {
  return DatabaseSizes(0, 0, count, 0, 0, 0, 0, 0);
 }

 static DatabaseSizes CounterOnly(uint16_t count)
 {
  return DatabaseSizes(0, 0, 0, count, 0, 0, 0, 0);
 }

 static DatabaseSizes FrozenCounterOnly(uint16_t count)
 {
  return DatabaseSizes(0, 0, 0, 0, count, 0, 0, 0);
 }

 static DatabaseSizes BinaryOutputStatusOnly(uint16_t count)
 {
  return DatabaseSizes(0, 0, 0, 0, 0, count, 0, 0);
 }

 static DatabaseSizes AnalogOutputStatusOnly(uint16_t count)
 {
  return DatabaseSizes(0, 0, 0, 0, 0, 0, count, 0);
 }

 static DatabaseSizes TimeAndIntervalOnly(uint16_t count)
 {
  return DatabaseSizes(0, 0, 0, 0, 0, 0, 0, count);
 }

 static DatabaseSizes AllTypes(uint16_t count)
 {
  return DatabaseSizes(count, count, count, count, count, count, count, count);
 }

 static DatabaseSizes Empty()
 {
  return DatabaseSizes(0, 0, 0, 0, 0, 0, 0, 0);
 }

 DatabaseSizes(uint16_t numBinary,
               uint16_t numDoubleBinary,
               uint16_t numAnalog,
               uint16_t numCounter,
               uint16_t numFrozenCounter,
               uint16_t numBinaryOutputStatus,
               uint16_t numAnalogOutputStatus,
               uint16_t numTimeAndInterval) :

  numBinary(numBinary),
  numDoubleBinary(numDoubleBinary),
  numAnalog(numAnalog),
  numCounter(numCounter),
  numFrozenCounter(numFrozenCounter),
  numBinaryOutputStatus(numBinaryOutputStatus),
  numAnalogOutputStatus(numAnalogOutputStatus),
  numTimeAndInterval(numTimeAndInterval)
 {}

 uint16_t numBinary;
 uint16_t numDoubleBinary;
 uint16_t numAnalog;
 uint16_t numCounter;
 uint16_t numFrozenCounter;
 uint16_t numBinaryOutputStatus;
 uint16_t numAnalogOutputStatus;
 uint16_t numTimeAndInterval;

};

}
# 28 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 1
# 24 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 1
# 25 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 2

# 1 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h" 1
# 34 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h"
namespace openpal
{
namespace sizes
{

static const uint16_t MAX_ERASURE_SIZE = 12 * sizeof(void*);

}
}
# 78 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h"
# 1 "/usr/include/c++/9/new" 1 3
# 37 "/usr/include/c++/9/new" 3
       
# 38 "/usr/include/c++/9/new" 3


# 1 "/usr/include/c++/9/exception" 1 3
# 33 "/usr/include/c++/9/exception" 3
       
# 34 "/usr/include/c++/9/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/9/bits/exception.h" 1 3
# 34 "/usr/include/c++/9/bits/exception.h" 3
       
# 35 "/usr/include/c++/9/bits/exception.h" 3

#pragma GCC visibility push(default)




# 40 "/usr/include/c++/9/bits/exception.h" 3
extern "C++" {

namespace std
{
# 60 "/usr/include/c++/9/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/9/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "/usr/include/c++/9/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 111 "/usr/include/c++/9/exception" 3
}

namespace __gnu_cxx
{

# 133 "/usr/include/c++/9/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/9/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/9/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/9/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/9/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 39 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/9/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/9/typeinfo" 1 3
# 32 "/usr/include/c++/9/typeinfo" 3
       
# 33 "/usr/include/c++/9/typeinfo" 3



# 1 "/usr/include/c++/9/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/9/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/9/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/9/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/9/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/9/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/include/c++/9/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/9/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/9/new" 1 3
# 41 "/usr/include/c++/9/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/usr/include/c++/9/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/usr/include/c++/9/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 208 "/usr/include/c++/9/bits/exception_ptr.h" 3
    }


}

}

#pragma GCC visibility pop
# 144 "/usr/include/c++/9/exception" 2 3
# 1 "/usr/include/c++/9/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/9/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/9/bits/move.h" 1 3
# 34 "/usr/include/c++/9/bits/move.h" 3
# 1 "/usr/include/c++/9/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/9/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/9/bits/concept_check.h" 3
# 35 "/usr/include/c++/9/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/usr/include/c++/9/type_traits" 1 3
# 32 "/usr/include/c++/9/type_traits" 3
       
# 33 "/usr/include/c++/9/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/9/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 185 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 243 "/usr/include/c++/9/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 323 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 351 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 758 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public is_constructible<_Tp>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public false_type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl<true, _Tp, _Args...>
    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<true, _Tp, _Arg>
    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<true, _Tp>
    : public __bool_constant<noexcept(_Tp())>
    { };

  template<typename _Tp, size_t _Num>
    struct __is_nt_constructible_impl<true, _Tp[_Num]>
    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
    { };

  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
       _Tp, _Args...>;


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>::type
    { };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __bool_constant<__is_assignable(_Tp, _Up)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<is_default_constructible<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };

  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };

  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };
# 1374 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1587 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<typename remove_cv<_Tp>::type>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1663 "/usr/include/c++/9/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1741 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<typename remove_cv<_Tp>::type>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1789 "/usr/include/c++/9/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1924 "/usr/include/c++/9/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 1963 "/usr/include/c++/9/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<>
    struct common_type<>
    { };

  template<typename _Tp>
    struct common_type<_Tp>
    : common_type<_Tp, _Tp>
    { };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;



  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;
# 2411 "/usr/include/c++/9/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2455 "/usr/include/c++/9/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2660 "/usr/include/c++/9/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3096 "/usr/include/c++/9/type_traits" 3

}
# 56 "/usr/include/c++/9/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 72 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 116 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 136 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 176 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/9/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 145 "/usr/include/c++/9/exception" 2 3
# 41 "/usr/include/c++/9/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 125 "/usr/include/c++/9/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 173 "/usr/include/c++/9/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 226 "/usr/include/c++/9/new" 3
#pragma GCC visibility pop
# 79 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h" 2
# 27 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 2


# 1 "/usr/include/assert.h" 1 3 4
# 30 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 2



# 32 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
namespace openpal
{




template <class ValueType, class IndexType>
class Array : public HasSize<IndexType>
{

public:

 Array(IndexType size) :
  HasSize<IndexType>(size),
  buffer(new ValueType[size]())
 {}

 Array() :
  HasSize<IndexType>(0),
  buffer(nullptr)
 {}

 Array(const Array& copy) :
  HasSize<IndexType>(copy.Size()),
  buffer(new ValueType[copy.Size()])
 {
  for(IndexType i = 0; i < copy.Size(); ++i) buffer[i] = copy.buffer[i];
 }

 ArrayView<ValueType, IndexType> ToView() const
 {
  return ArrayView<ValueType, IndexType>(buffer, this->size);
 }

 inline bool Contains(IndexType index) const
 {
  return index < this->size;
 }

 inline ValueType& operator[](IndexType index)
 {
  
# 73 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 3 4
 (static_cast<void> (0))
# 73 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
                           ;
  return buffer[index];
 }

 const ValueType& operator[](IndexType index) const
 {
  
# 79 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 3 4
 (static_cast<void> (0))
# 79 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
                           ;
  return buffer[index];
 }

 template <class Action>
 void foreach(const Action& action) const
 {
  for(IndexType i = 0; i < this->size; ++i) action(buffer[i]);
 }

 template <class Action>
 void foreach(const Action& action)
 {
  for(IndexType i = 0; i < this->size; ++i) action(buffer[i]);
 }

 template <class Action>
 void foreachIndex(const Action& action)
 {
  for(IndexType i = 0; i < this->size; ++i) action(buffer[i], i);
 }


 template <class Action>
 void foreachIndex(const Action& action) const
 {
  for(uint32_t i = 0; i < this->size; ++i) action(buffer[i], i);
 }

 virtual ~Array()
 {
  delete[] buffer;
 }

protected:

 ValueType* buffer;

private:

 Array& operator=(const Array&) = delete;
};

}
# 30 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.h" 2



namespace opendnp3
{




class StaticBuffers : private openpal::Uncopyable
{

public:

 explicit StaticBuffers(const DatabaseSizes& dbSizes);

 DatabaseConfigView GetView() const;


 template <class Spec>
 openpal::ArrayView<Cell<Spec>, uint16_t> GetArrayView();

private:

 template <class Spec>
 void SetDefaultIndices()
 {
  auto view = GetArrayView<Spec>();
  for (uint16_t i = 0; i < view.Size(); ++i)
  {
   view[i].config.vIndex = i;
  }
 }

 openpal::Array<Cell<BinarySpec>, uint16_t> binaries;
 openpal::Array<Cell<DoubleBitBinarySpec>, uint16_t> doubleBinaries;
 openpal::Array<Cell<AnalogSpec>, uint16_t> analogs;
 openpal::Array<Cell<CounterSpec>, uint16_t> counters;
 openpal::Array<Cell<FrozenCounterSpec>, uint16_t> frozenCounters;
 openpal::Array<Cell<BinaryOutputStatusSpec>, uint16_t> binaryOutputStatii;
 openpal::Array<Cell<AnalogOutputStatusSpec>, uint16_t> analogOutputStatii;
 openpal::Array<Cell<TimeAndIntervalSpec>, uint16_t> timeAndIntervals;
};

}
# 22 "/home/kimchaer/Desktop/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/StaticBuffers.cpp" 2

namespace opendnp3
{

StaticBuffers::StaticBuffers(const DatabaseSizes& dbSizes) :
 binaries(dbSizes.numBinary),
 doubleBinaries(dbSizes.numDoubleBinary),
 analogs(dbSizes.numAnalog),
 counters(dbSizes.numCounter),
 frozenCounters(dbSizes.numFrozenCounter),
 binaryOutputStatii(dbSizes.numBinaryOutputStatus),
 analogOutputStatii(dbSizes.numAnalogOutputStatus),
 timeAndIntervals(dbSizes.numTimeAndInterval)
{
 this->SetDefaultIndices<BinarySpec>();
 this->SetDefaultIndices<DoubleBitBinarySpec>();
 this->SetDefaultIndices<CounterSpec>();
 this->SetDefaultIndices<FrozenCounterSpec>();
 this->SetDefaultIndices<AnalogSpec>();
 this->SetDefaultIndices<BinaryOutputStatusSpec>();
 this->SetDefaultIndices<AnalogOutputStatusSpec>();
 this->SetDefaultIndices<TimeAndIntervalSpec>();
}

DatabaseConfigView StaticBuffers::GetView() const
{
 return DatabaseConfigView(
            binaries.ToView(),
            doubleBinaries.ToView(),
            analogs.ToView(),
            counters.ToView(),
            frozenCounters.ToView(),
            binaryOutputStatii.ToView(),
            analogOutputStatii.ToView(),
            timeAndIntervals.ToView()
        );
}

template <>
openpal::ArrayView<Cell<BinarySpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return binaries.ToView();
}

template <>
openpal::ArrayView<Cell<DoubleBitBinarySpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return doubleBinaries.ToView();
}

template <>
openpal::ArrayView<Cell<CounterSpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return counters.ToView();
}

template <>
openpal::ArrayView<Cell<FrozenCounterSpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return frozenCounters.ToView();
}

template <>
openpal::ArrayView<Cell<AnalogSpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return analogs.ToView();
}

template <>
openpal::ArrayView<Cell<BinaryOutputStatusSpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return binaryOutputStatii.ToView();
}

template <>
openpal::ArrayView<Cell<AnalogOutputStatusSpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return analogOutputStatii.ToView();
}

template <>
openpal::ArrayView<Cell<TimeAndIntervalSpec>, uint16_t> StaticBuffers::GetArrayView()
{
 return timeAndIntervals.ToView();
}

}
